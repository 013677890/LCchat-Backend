# 补充数据结构文档：Msg-Service 与 Connect-Service 全接口结构

> **范围**：`03_数据结构与流转链路全解.md` 仅覆盖了 **SendMessage** 的完整链路。  
> 本文档补充 msg-service 剩余接口（拉取、撤回、会话管理）和 connect-service 全接口的数据结构。

---

## 一、Msg-Service 剩余接口

---

### 1. PullMessages — 按会话增量拉取历史消息

**调用链路**：`Client → Gateway (HTTP GET) → msg-service (gRPC)`

#### 请求（HTTP 层）

```
GET /api/v1/auth/msg/pull?conv_id=p2p-usr_abc-usr_def&anchor_seq=40&direction=1&limit=50
Authorization: Bearer <access_token>
```

#### 请求（gRPC 层）

```protobuf
// proto/msg/msg_service.proto
message PullMessagesRequest {
  string conv_id = 1;          // 目标会话 ID
  int64 anchor_seq = 2;        // 锚点 seq（以此为基准拉取前后消息）
  int32 limit = 3;             // 单次拉取上限（默认50，最大200）
  PullDirection direction = 4; // 拉取方向
}

enum PullDirection {
  PULL_DIRECTION_UNSPECIFIED = 0; // 默认等同 FORWARD
  PULL_DIRECTION_FORWARD    = 1; // seq > anchor_seq（拉新消息）
  PULL_DIRECTION_BACKWARD   = 2; // seq < anchor_seq（加载历史）
}
```

**转化动作**：
- Gateway 将 Query 参数映射到 Proto 字段
- Gateway 从 JWT 提取 `owner_uuid`，用于服务端鉴权（确认该用户有权拉取此会话）
- 服务端增加 `seq > clear_seq` 过滤条件，防止已删除会话的历史消息"幽灵复活"

#### 响应（gRPC 层）

```protobuf
message PullMessagesResponse {
  repeated MsgItem messages = 1; // 按 seq 升序排列的消息列表
  bool has_more = 2;             // 是否还有更多可拉取
  int64 max_seq = 3;             // 该会话当前最大 seq（客户端判断 gap 用）
}
```

#### 响应（HTTP 层）

```json
{
  "code": 0,
  "data": {
    "messages": [
      {
        "msg_id": "01HW5K...",
        "client_msg_id": "c3f8a1b2-...",
        "conv_id": "p2p-usr_abc-usr_def",
        "seq": 41,
        "from_uuid": "usr_abc",
        "msg_type": 1,
        "content": "{\"text\":\"你好\"}",
        "status": 0,
        "send_time": 1740391200000,
        "reply_to_msg_id": "",
        "at_users": []
      }
    ],
    "has_more": false,
    "max_seq": 42
  },
  "timestamp": 1740391200000
}
```

**MsgItem → JSON 转化**：Proto 的 `MsgItem` 各字段直接映射为 JSON 的 camelCase/snake_case 字段。`at_users`（repeated string）映射为 JSON 数组。

---

### 2. GetMessagesByIds — 批量按 ID 查询消息

**调用链路**：`Client → Gateway (HTTP POST) → msg-service (gRPC)`

#### 请求（gRPC 层）

```protobuf
message GetMessagesByIdsRequest {
  string conv_id = 1;          // 会话 ID（用于定位分表/索引）
  repeated string msg_ids = 2; // 要查询的消息 ID 列表（1~50 条）
}
```

#### 响应（gRPC 层）

```protobuf
message GetMessagesByIdsResponse {
  repeated MsgItem messages = 1; // 查到的消息（顺序不保证，找不到的静默跳过）
}
```

**典型场景**：
- 用户点击引用/回复区域，需跳转到原始消息
- 推送通知只携带 `msg_id`，客户端需反查详情

---

### 3. RecallMessage — 消息撤回

**调用链路**：`Client → Gateway (HTTP POST) → msg-service (gRPC) → Kafka → Connect → Client`

#### 请求（HTTP 层）

```json
{
  "conv_id": "p2p-usr_abc-usr_def",
  "msg_id": "01HW5K9Q1ZBXK3EJGA7MKYQ4XT"
}
```

> `operator_uuid` 不在请求体中，由 Gateway 从 JWT 提取后注入 gRPC。

#### 请求（gRPC 层）

```protobuf
message RecallMessageRequest {
  string conv_id = 1;         // 会话 ID
  string msg_id = 2;          // 要撤回的消息 ID
  string operator_uuid = 3;   // 操作者 UUID（Gateway 注入）
}
```

**服务端处理流程**：
1. 校验 `operator_uuid` 是否为消息发送者或群管理员
2. 校验是否在 2 分钟撤回窗口内
3. 更新 DB：`status=1`，`content` 改写为撤回提示 JSON
4. 写 Kafka：`MsgPushEvent{ type="MSG_RECALL", data=RecallNotice }`

#### 响应（gRPC 层）

```protobuf
message RecallMessageResponse {} // 空响应，成功即代表撤回完成
```

#### 异步下行推送

msg-service 撤回成功后写入 Kafka 的 `MsgPushEvent`：

```
MsgPushEvent {
  type = "MSG_RECALL"
  data = RecallNotice (proto bytes) {
    conv_id     = "p2p-usr_abc-usr_def"
    msg_id      = "01HW5K..."
    operator    = "usr_abc"
    recall_time = 1740391260000
  }
}
```

Connect 消费后封装为 `MessageEnvelope{ type="MSG_RECALL", data=RecallNotice }` 推送到会话内所有在线设备。客户端收到后将对应气泡替换为"撤回了一条消息"。

---

## 二、Msg-Service 会话管理接口

---

### 4. GetConversations — 获取会话列表

**调用链路**：`Client → Gateway (HTTP GET) → msg-service (gRPC)`

#### 请求（gRPC 层）

```protobuf
message GetConversationsRequest {
  string owner_uuid = 1;   // 会话归属用户（Gateway 注入）
  int64 updated_since = 2; // 增量起始时间戳（0=全量）
  int32 page_size = 3;     // 分页大小（默认50，上限200）
  int64 cursor = 4;        // 分页游标（上一页最后一条的 updated_at）
}
```

#### 响应（gRPC 层）

```protobuf
message GetConversationsResponse {
  repeated ConversationItem conversations = 1; // 会话列表（按 updated_at 倒序）
  bool has_more = 2;
  int64 next_cursor = 3; // 绝对不能返回 0，必须取列表中最大 updated_at
}
```

#### `ConversationItem` 结构（gRPC → JSON 映射）

```protobuf
message ConversationItem {
  string conv_id = 1;       // → "conv_id"
  ConvType conv_type = 2;   // → "conv_type" (1=单聊 2=群聊)
  string target_uuid = 3;   // → "target_uuid"
  MsgItem last_msg = 4;     // → "last_msg" (嵌套对象，可为空)
  int32 unread_count = 5;   // → "unread_count"
  bool mute = 6;            // → "mute"
  bool pin = 7;             // → "pin"
  int64 updated_at = 8;     // → "updated_at"（用于游标分页）
  string last_msg_sender_name = 9;   // → "last_msg_sender_name"（快照）
  string last_msg_sender_avatar = 10; // → "last_msg_sender_avatar"（快照）
}
```

**转化动作**（服务端生成 ConversationItem）：
- 从 `model.Conversation` 取基础字段
- `unread_count`：单聊直接取 `max(0, max_seq - read_seq)`；群聊通过 `max(0, group.max_seq - member.read_seq)` 动态计算
- `last_msg`：通过 `last_msg_id` 关联查询 `Message` 表，转为 `MsgItem`
- `last_msg_sender_name/avatar`：快照字段，用户改名后不回写历史

---

### 5. MarkRead — 标记已读

**调用链路**：`Client → Gateway (HTTP POST) → msg-service (gRPC) → Kafka → Connect（多端同步）`

#### 请求（gRPC 层）

```protobuf
message MarkReadRequest {
  string conv_id = 1;     // 会话 ID
  string owner_uuid = 2;  // 归属用户（Gateway 注入）
  int64 read_seq = 3;     // 客户端已读到的最大 seq（> 0）
}
```

#### 响应（gRPC 层）

```protobuf
message MarkReadResponse {
  int32 unread_count = 1;
  // 由 max(0, conv.max_seq - read_seq) 动态计算，
  // 并发新消息插入时可能大于 0
}
```

**服务端处理**：
1. `read_seq = max(DB.read_seq, req.read_seq)`（单调递增）
2. 计算 `unread_count = max(0, max_seq - read_seq)`
3. 写 Kafka：`MsgPushEvent{ type="MSG_MARK_READ", data=MarkReadNotice }` → 多端同步

#### 异步下行推送（多端同步）

```
MsgPushEvent {
  type = "MSG_MARK_READ"
  data = MarkReadNotice (proto bytes) {
    conv_id  = "p2p-usr_abc-usr_def"
    read_seq = 42
  }
}
```

Connect 消费后推送给该用户的**其他在线设备**，各端据此清除红点。

---

### 6. DeleteConversation — 删除会话

**调用链路**：`Client → Gateway (HTTP DELETE) → msg-service (gRPC)`

#### 请求（gRPC 层）

```protobuf
message DeleteConversationRequest {
  string conv_id = 1;     // 会话 ID
  string owner_uuid = 2;  // 归属用户（Gateway 注入）
}
```

#### 响应（gRPC 层）

```protobuf
message DeleteConversationResponse {} // 空响应
```

**服务端处理**：
1. `status = 1`（逻辑删除）
2. `clear_seq = 当前 max_seq`
3. `read_seq = max_seq`（未读数归零）
4. 后续 PullMessages 自动加 `seq > clear_seq` 过滤

---

### 7. UpdateConversationSettings — 更新会话设置

**调用链路**：`Client → Gateway (HTTP PATCH) → msg-service (gRPC)`

#### 请求（gRPC 层）

```protobuf
message UpdateConvSettingsRequest {
  string conv_id = 1;       // 会话 ID
  string owner_uuid = 2;    // 归属用户（Gateway 注入）
  optional bool mute = 3;   // 免打扰（仅传需要修改的）
  optional bool pin = 4;    // 置顶（仅传需要修改的）
}
```

#### 响应（gRPC 层）

```protobuf
message UpdateConvSettingsResponse {} // 空响应
```

**optional 语义**：Proto3 `optional` 保证未传入的字段不会被覆盖，只更新有值的字段。

---

## 三、Connect-Service gRPC 接口（精确投递管道）

> **架构定位（方案B：Dispatcher + 路由表）**：
> Connect-Service 是有状态的（Stateful）节点，但它**不需要被随机负载均衡调用**。
> 上游的 Push-Job（Kafka 消费者调度器）会先查 Redis 路由表（`HGETALL user:routing:{uuid}`），
> 精确获取目标用户所在的 Connect 节点 IP，然后通过 gRPC **直连**该节点。
> Connect 本身只是一个"纯管道"：收到 gRPC 请求后，直接往 WebSocket 塞数据，不做任何业务判断。

---

### 8. PushToDevice — 向指定用户的指定设备投递

**调用方**：Push-Job（Self-Sync 场景：向发送方的其他设备投递）

```protobuf
message PushToDeviceRequest {
  string user_uuid = 1;           // 目标用户 UUID
  string device_id = 2;           // 目标设备 ID
  MessageEnvelope message = 3;    // 待投递的消息封装
}

message PushToDeviceResponse {
  bool delivered = 1; // true=目标连接存在且已成功入队
}
```

---

### 9. PushToUser — 向用户在本节点上的所有在线设备广播

**调用方**：Push-Job（查到用户在此节点，推送全设备）

```protobuf
message PushToUserRequest {
  string user_uuid = 1;           // 目标用户 UUID
  MessageEnvelope message = 2;    // 待广播消息体
}

message PushToUserResponse {
  int32 delivered_count = 1; // 成功入队的设备数量
}
```

---

### 10. BroadcastToUsers — 批量向多个用户广播

**调用方**：管理后台（全服维护公告等系统级广播，遍历所有 Connect 节点调用）

```protobuf
message BroadcastToUsersRequest {
  repeated string user_uuids = 1; // 目标用户列表（单次上限 1000）
  MessageEnvelope message = 2;    // 所有用户收到相同的消息体
}

message BroadcastToUsersResponse {
  int32 success_count = 1;    // 至少有一个设备成功入队的用户数
  int32 total_delivered = 2;  // 所有设备成功入队的总数
}
```

---

### 11. KickConnection — 主动断开指定设备连接

**调用方**：user-service（封禁账号/异地登录时踢线）

> **Stateful 悖论的解法**：User-Service 在踢线前先查 Redis 路由表
> `HGET user:routing:{uuid} {device_id}` 获取目标所在 Connect 节点的 gRPC 地址，
> 然后**直连**该节点调用 KickConnection，避免负载均衡打到错误节点。

```protobuf
message KickConnectionRequest {
  string user_uuid = 1; // 目标用户 UUID
  string device_id = 2; // 目标设备 ID
  string reason = 3;    // 踢线原因（客户端据此提示"账号在其他设备登录"等）
}

message KickConnectionResponse {
  bool success = 1; // true=连接已断开；false=目标原本不在线
}
```

**下行推送**：踢线时 Connect 会先向被踢设备发送 `MessageEnvelope{ type="KICKOUT" }` 帧，客户端收到后跳转登录页，然后 Connect 才关闭 TCP 连接。

---

### 12. Redis 路由表（在线状态 + 节点定位）

Connect 在**建连**和**心跳**时维护此 Hash，**断连**时删除对应 Field：

```redis
// Key：user:routing:{user_uuid}
// Type：Hash
// Field = device_id
// Value = Connect 节点的 gRPC 地址（如 "10.0.0.5:9091"）

// 示例：
HSET user:routing:usr_abc device_phone "10.0.0.5:9091"
HSET user:routing:usr_abc device_pc    "10.0.0.8:9091"

// Push-Job / User-Service 查询：
HGETALL user:routing:usr_abc
// → { "device_phone": "10.0.0.5:9091", "device_pc": "10.0.0.8:9091" }

// 判断是否在线（Hash 是否有成员）：
HLEN user:routing:usr_abc
// → 2（在线）/ 0（离线）
```

**谁来维护？** Connect 节点自己。
**谁来查询？** Push-Job（投递消息）、User-Service（踢线）、业务层（在线状态指示灯）。
**不再需要** Connect 暴露 `GetOnlineStatus` gRPC 接口——直接查 Redis 即可。

---

### 13. MessageEnvelope — WebSocket 下行统一封装格式

---

## 四、通用枚举与数据类型速查

### ConvType — 会话类型

```protobuf
enum ConvType {
  CONV_TYPE_UNSPECIFIED = 0; // 未指定
  CONV_TYPE_P2P         = 1; // 单聊
  CONV_TYPE_GROUP       = 2; // 群聊
}
```

### MsgItem — 消息完整结构（跨多接口复用）

```protobuf
message MsgItem {
  string msg_id = 1;             // 全局唯一消息 ID
  string client_msg_id = 2;      // 客户端幂等 ID
  string conv_id = 3;            // 所属会话 ID
  int64 seq = 4;                 // 会话内严格递增序号
  string from_uuid = 5;          // 发送者 UUID
  int32 msg_type = 6;            // 消息类型（0-99 普通，100+ 系统）
  string content = 7;            // 消息内容 JSON
  int32 status = 8;              // 0=正常 1=撤回 2=删除
  int64 send_time = 9;           // 发送时间（unix 毫秒）
  string reply_to_msg_id = 10;   // 引用回复的目标消息 ID
  repeated string at_users = 11; // 被@用户 UUID 列表
}
```

**复用场景**：
- `SendMessage` 落库后转为 `MsgItem` 写入 Kafka
- `PullMessages` / `GetMessagesByIds` 响应中返回
- `MessageEnvelope` 的 `data` 字段解码后得到
- `ConversationItem.last_msg` 嵌套引用
