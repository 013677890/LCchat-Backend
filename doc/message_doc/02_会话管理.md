# 会话管理接口文档

> **版本**: v1.1.0  
> **更新时间**: 2026-02-24  
> **依赖**: 需先完成 WebSocket 连接认证（见 `01_消息发送全流程.md §2`）

---

## 目录

- [1. 获取会话列表](#1-获取会话列表)
- [2. 标记已读](#2-标记已读)
- [3. 删除会话](#3-删除会话)
- [4. 会话设置（免打扰/置顶）](#4-会话设置免打扰置顶)
- [5. 数据模型](#5-数据模型)

---

## 1. 获取会话列表

### 1.1 全量拉取（首次登录）

```
GET /api/v1/auth/conversations?updated_since=0&page_size=50&cursor=0
Authorization: Bearer <access_token>
```

### 1.2 增量同步（上线时）

```
GET /api/v1/auth/conversations?updated_since=1740391200000&page_size=50&cursor=0
Authorization: Bearer <access_token>
```

**Query 参数**：

| 参数 | 类型 | 必填 | 默认 | 说明 |
|------|------|------|------|------|
| `updated_since` | int64 | ❌ | 0 | Unix 毫秒；`0` 表示全量，否则只返回该时间点后有变更的会话 |
| `page_size` | int | ❌ | 50 | 每页条数，上限 200 |
| `cursor` | int64 | ❌ | 0 | 分页游标（上一页最后一条的 `updated_at`），首页传 0 |

> **游标返回规则（必须严格遵守）**：  
> - `next_cursor` **绝对不能返回 0**，即使 `has_more=false`。  
> - `next_cursor` 必须严格取本次返回的会话列表中 **最大的 `updated_at` 值**。  
> - 这样客户端在下次拉取时能实现精准的断点续传，不会重复拉取已同步的会话。  
> - 当结果为空（无会话满足条件）时，`next_cursor` 返回请求中的 `updated_since` 值。

**成功响应**：

```json
{
  "code": 0,
  "data": {
    "conversations": [
      {
        "conv_id":     "p2p-usr_abc-usr_def",
        "conv_type":   1,
        "target_uuid": "usr_def",
        "last_msg": {
          "msg_id":    "01HW5K9Q1ZBXK3EJGA7MKYQ4XT",
          "from_uuid": "usr_abc",
          "msg_type":  1,
          "content":   "{\"text\":\"你好！\"}",
          "seq":       42,
          "status":    0,
          "send_time": 1740391200000
        },
        "unread_count":           3,
        "mute":                   false,
        "pin":                    false,
        "updated_at":             1740391200000,
        "last_msg_sender_name":   "张三",
        "last_msg_sender_avatar": "https://cdn.example.com/avatars/usr_abc.jpg"
      }
    ],
    "has_more":    false,
    "next_cursor": 1740391200000
  },
  "timestamp": 1740391200000
}
```

**ConversationItem 字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| `conv_id` | string | 会话唯一 ID |
| `conv_type` | int | `1`=单聊，`2`=群聊 |
| `target_uuid` | string | 单聊为对端 UUID，群聊为群 UUID |
| `last_msg` | MsgItem | 最后一条消息摘要（可为空） |
| `unread_count` | int | 未读消息数 |
| `mute` | bool | 是否免打扰 |
| `pin` | bool | 是否置顶 |
| `updated_at` | int64 | 会话最后更新时间（Unix 毫秒），用于增量同步 |
| `last_msg_sender_name` | string | 最后消息发送者昵称快照 |
| `last_msg_sender_avatar` | string | 最后消息发送者头像快照 |

> **注意**：`last_msg_sender_name` / `last_msg_sender_avatar` 为发送时的快照，用户改名后不回写历史会话，需客户端覆盖展示最新用户信息。

---

## 2. 标记已读

将指定会话的已读位点更新到 `read_seq`，服务端通过公式动态计算剩余未读数，并通知该用户其他在线设备。

```
POST /api/v1/auth/conversations/mark-read
Authorization: Bearer <access_token>
Content-Type: application/json
```

**请求体**：

```json
{
  "conv_id":  "p2p-usr_abc-usr_def",
  "read_seq": 42
}
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `conv_id` | string | ✅ | 目标会话 ID |
| `read_seq` | int64 | ✅ | 客户端已读到的最大 seq（> 0） |

**服务端逻辑**：

1. 更新该用户的 `read_seq = max(DB.read_seq, req.read_seq)`（单调递增，防止回退）。
2. 通过公式动态计算未读数：`unread_count = max(0, conv.max_seq - read_seq)`。
3. 向该用户其他在线设备推送 `MSG_MARK_READ` 通知。

> **为什么不直接清零 unread_count？**  
> 如果在标记已读和响应之间有并发新消息插入，直接清零会导致漏读。通过 `max_seq - read_seq` 动态计算可确保并发安全。

**成功响应**：

```json
{
  "code": 0,
  "data": {
    "unread_count": 2
  },
  "timestamp": 1740391200000
}
```

> `unread_count` 由公式计算得出，若在标记已读期间有并发新消息插入，此处可能大于 0。
```

**多端同步推送**：

标记已读后，服务端向该用户的其他在线设备推送 `MSG_MARK_READ` 通知：

```protobuf
MessageEnvelope {
  command = "MSG_MARK_READ"
  payload = MarkReadNotice {
    conv_id  = "p2p-usr_abc-usr_def"
    read_seq = 42
  }
}
```

---

## 3. 删除会话

逻辑删除会话（`status=1`），**并记录当前会话的清空位点 `clear_seq`**，以实现彻底清空历史聊天记录。

```
DELETE /api/v1/auth/conversations/{conv_id}
Authorization: Bearer <access_token>
```

**Path 参数**：

| 参数 | 类型 | 说明 |
|------|------|------|
| `conv_id` | string | 要删除的会话 ID |

**服务端逻辑**：

1. 将会话 `status` 置为 `1`（逻辑删除）。
2. 记录清空位点：`clear_seq = 当前会话的 max_seq`。
3. 重置已读位点：`read_seq = max_seq`（未读数归零）。

> **clear_seq 的作用**：  
> - 用户下次拉取历史消息时，服务端会加上 `seq > clear_seq` 过滤条件，确保删除前的消息不会“幽灵复活”。  
> - 当用户从未删除过会话时，`clear_seq = 0`，不影响正常查询。  
> - 当对端再次发消息时，会话自动重新激活（`status` 置回 `0`），但 `clear_seq` 保持不变，旧消息仍不可见。

**成功响应**：

```json
{
  "code":    0,
  "message": "success",
  "timestamp": 1740391200000
}
```

> **幂等性**：会话已删除时重复调用仍返回成功。

---

## 4. 会话设置（免打扰/置顶）

```
PATCH /api/v1/auth/conversations/{conv_id}/settings
Authorization: Bearer <access_token>
Content-Type: application/json
```

**Path 参数**：

| 参数 | 类型 | 说明 |
|------|------|------|
| `conv_id` | string | 目标会话 ID |

**请求体**（仅传需要修改的字段，未传字段保持不变）：

```json
{
  "mute": true,
  "pin":  false
}
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `mute` | bool | ❌ | `true`=开启免打扰，`false`=关闭 |
| `pin` | bool | ❌ | `true`=置顶，`false`=取消置顶 |

**成功响应**：

```json
{
  "code":    0,
  "message": "success",
  "timestamp": 1740391200000
}
```

---

## 5. 数据模型

### 5.1 MsgItem（消息条目）

| 字段 | 类型 | 说明 |
|------|------|------|
| `msg_id` | string | 全局唯一消息 ID（ULID） |
| `client_msg_id` | string | 客户端幂等 ID |
| `conv_id` | string | 所属会话 ID |
| `seq` | int64 | 会话内严格递增序号 |
| `from_uuid` | string | 发送者 UUID |
| `msg_type` | int32 | 消息类型（见消息类型定义） |
| `content` | string | 消息内容（JSON 字符串） |
| `status` | int32 | `0`=正常，`1`=撤回，`2`=删除 |
| `send_time` | int64 | 发送时间（Unix 毫秒） |
| `reply_to_msg_id` | string | 引用消息 ID（空表示非回复） |
| `at_users` | []string | 被 @ 的用户 UUID 列表 |

### 5.2 ConversationItem（会话条目）

| 字段 | 类型 | 说明 |
|------|------|------|
| `conv_id` | string | 会话 ID |
| `conv_type` | int | `1`=单聊，`2`=群聊 |
| `target_uuid` | string | 单聊对端/群 UUID |
| `last_msg` | MsgItem | 最后消息（可为空） |
| `unread_count` | int | 该用户的未读数 |
| `mute` | bool | 免打扰 |
| `pin` | bool | 置顶 |
| `updated_at` | int64 | 最后变更时间（Unix 毫秒） |
| `last_msg_sender_name` | string | 发送者昵称快照 |
| `last_msg_sender_avatar` | string | 发送者头像快照 |

---

*本文档与 `proto/msg/msg_service.proto`（GetConversations / MarkRead / DeleteConversation / UpdateConvSettings）保持同步。*
