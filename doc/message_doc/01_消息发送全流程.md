# 消息发送全流程文档

> **版本**: v2.0.0  
> **更新时间**: 2026-02-24  
> **覆盖范围**: Gateway HTTP 上行 → msg-service 落库 → Kafka → connect-service 下行推送  
> **数据格式**: 上行 HTTP JSON / Kafka payload Protobuf Binary / 下行 WebSocket Binary

---

## 目录

- [1. 端到端链路总览](#1-端到端链路总览)
- [2. WebSocket 连接（长连接层）](#2-websocket-连接长连接层)
- [3. 发送消息（Gateway HTTP 上行）](#3-发送消息gateway-http-上行)
- [4. 下行推送：消息到达客户端](#4-下行推送消息到达客户端)
- [5. 消息拉取（历史记录）](#5-消息拉取历史记录)
- [6. 消息撤回](#6-消息撤回)
- [7. 消息类型定义](#7-消息类型定义)
- [8. 错误码](#8-错误码)
- [9. 设计要点](#9-设计要点)

---

## 1. 端到端链路总览

> 设计原则：**上行走 Gateway（HTTP JSON，开发友好），下行走 Connect（WebSocket Binary，高吞吐）**。
> Connect 服务**不处理消息上行**，只负责心跳、下行推送和连接管理。

```
┌──────────┐  HTTP JSON     ┌──────────────┐  gRPC SendMessage  ┌──────────────┐
│  Client  │ ──────────────>│   Gateway    │ ─────────────────> │   msg-svc    │
│          │                │  (HTTP API)  │ <─ gRPC Response   │              │
│          │                │  鉴权/校验   │                    │ ①幂等检查    │
│          │  HTTP JSON Resp│  JSON→Proto  │                    │ ②落库 message│
│          │ <──────────────│              │                    │ ③分配 seq    │
│          │                └──────────────┘                    │ ④upsert 会话 │
│          │                                                   │ ⑤写 Kafka    │
│          │  WS Binary帧   ┌──────────────┐  Kafka msg.push   └──────────────┘
│          │ <──────────────│   Connect    │ <─────────────────
│          │  Proto解码     │ (kafka csmr) │
│          │  ──heartbeat─> │ (ws server)  │
└──────────┘                └──────────────┘
```

**各阶段协议说明**：

| 阶段 | 协议 | 说明 |
|------|------|------|
| 客户端 → Gateway | HTTP POST, JSON Body | 上行发消息，Gateway 负责鉴权、校验、JSON→Proto 转换 |
| Gateway → msg-service | gRPC 内网调用 | `MsgService.SendMessage`，同步等待落库结果 |
| msg-service → Kafka | **Protobuf Binary**（`MsgPushEvent`） | 序列化为二进制写入 topic，高吞吐低带宽 |
| Connect 消费 Kafka | Kafka Consumer，Protobuf 反序列化 | 解码 `MsgPushEvent`，路由到目标在线设备 |
| Connect → 客户端 | WebSocket Binary, `MessageEnvelope` Proto | 最终下行推送 |
| 客户端 ↔ Connect | WebSocket Text, JSON Envelope | **仅限心跳**（heartbeat / heartbeat_ack） |

---

## 2. WebSocket 连接（长连接层）

客户端需建立 WebSocket 连接用于**接收下行推送**和**心跳保活**。

> **注意**：消息发送**不走 WebSocket**，而是通过 Gateway HTTP 接口。
> Connect 服务只处理 `heartbeat` 类型的上行帧，收到 `message` 类型会返回 `error` 帧。

### 2.1 连接地址

```
GET ws://{connect-host}:8081/ws?token={access_token}&device_id={device_id}
```

| 参数 | 必填 | 说明 |
|------|------|------|
| `token` | ✅ | 登录后获取的 Access Token（JWT） |
| `device_id` | ✅ | 设备唯一 ID，与颁发 token 时的 device_id 一致 |

### 2.2 鉴权逻辑

1. 服务端解析 JWT，验证 `claims.DeviceID == query.device_id`。
2. 校验 Redis `auth:at:{user_uuid}:{device_id}` 存储的 token MD5 是否一致。
3. 校验失败返回 HTTP 4xx（握手阶段，非 WebSocket 帧）。

**鉴权失败响应**：

```json
// HTTP 401
{
  "code": 22001,
  "message": "token 无效或已过期",
  "trace_id": "...",
  "timestamp": 1740391200000
}
```

### 2.3 心跳保活

客户端应每 **30 秒**发送一次心跳，防止连接被中间网关超时断开。

**上行（客户端发）**：
```json
{ "type": "heartbeat" }
```

**下行（服务端回）**：
```json
{ "type": "heartbeat_ack" }
```

### 2.4 下行帧格式

Connect 推送的消息使用 **WebSocket Binary 帧 + Protobuf** 编码（详见 [§4 下行推送](#4-下行推送消息到达客户端)）。

---

## 3. 发送消息（Gateway HTTP 上行）

消息发送统一通过 **Gateway HTTP** 接口，Gateway 完成鉴权、参数校验、JSON → Proto 转换后，通过 gRPC 调用 msg-service。

### 3.1 请求

```
POST /api/v1/auth/msg/send
Authorization: Bearer <access_token>
X-Device-ID: <device_id>
Content-Type: application/json
```

**请求体**：

```json
{
  "client_msg_id":    "c3f8a1b2-0000-0000-0000-123456789abc",
  "conv_type":        1,
  "target_uuid":      "usr_abcdefghij",
  "msg_type":         1,
  "content":          "{\"text\":\"你好！\"}",
  "reply_to_msg_id":  "",
  "at_users":         []
}
```

**字段说明**：

| 字段 | 类型 | 必填 | 校验规则 |
|------|------|------|----------|
| `client_msg_id` | string | ✅ | 1~64 字符，客户端生成的幂等 ID（建议 UUID v4） |
| `conv_type` | int | ✅ | `1`(单聊) 或 `2`(群聊) |
| `target_uuid` | string | ✅ | 单聊为对端 UUID，群聊为群 UUID |
| `msg_type` | int | ✅ | 消息类型代号，见 [§7 消息类型定义](#7-消息类型定义) |
| `content` | string | ✅ | 消息内容（JSON 字符串），1~65536 字节 |
| `reply_to_msg_id` | string | ❌ | 引用/回复的目标消息 ID（空字符串表示非回复） |
| `at_users` | []string | ❌ | 被 @ 的用户 UUID 列表；@全员使用 `"00000000000000000000"` |

### 3.2 服务端处理流程

```
Client POST /api/v1/auth/msg/send
  │
  ├─ Gateway:
  │   ├─ JWTAuthMiddleware 鉴权，提取 user_uuid / device_id
  │   ├─ 参数校验（validate rules）
  │   ├─ JSON → SendMessageRequest proto（protojson 转换）
  │   ├─ 透传 trace_id / user_uuid / device_id / client_ip 到 gRPC metadata
  │   └─ gRPC 调用 msg-service.SendMessage(...)  ← 同步等待
  │
  ├─ msg-service:
  │   ├─ 幂等检查（client_msg_id + from_uuid + device_id）
  │   ├─ 生成 msg_id（ULID）
  │   ├─ Redis INCR 分配 seq（key: msg:seq:{conv_id}）
  │   ├─ 落库 message 表
  │   ├─ upsert conversation（last_msg / unread_count++）
  │   └─ 写 Kafka topic "msg.push"  ← Protobuf Binary（MsgPushEvent）
  │
  └─ Gateway 返回 HTTP JSON 给客户端

── 异步路径（Kafka Consumer，Connect 独立 goroutine）───────────
Connect 消费 Kafka "msg.push"
  ├─ proto.Unmarshal(bytes) → MsgPushEvent
  ├─ 按 receiver_uuid 路由：SendToUser / SendToDevice
  └─ WebSocket Binary 帧推送给在线客户端
```

### 3.3 成功响应

```json
{
  "code":    0,
  "message": "success",
  "data": {
    "msg_id":    "01HW5K9Q1ZBXK3EJGA7MKYQ4XT",
    "seq":       42,
    "conv_id":   "p2p-usr_abc-usr_def",
    "send_time": 1740391200000
  },
  "trace_id":  "abc-123",
  "timestamp": 1740391200000
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| `msg_id` | string | 服务端分配的全局唯一消息 ID |
| `seq` | int64 | 会话内严格递增序号 |
| `conv_id` | string | 会话 ID（首次发消息时由服务端生成） |
| `send_time` | int64 | 服务端时间，Unix 毫秒 |

### 3.4 错误响应示例

```json
{
  "code":      13001,
  "message":   "消息发送失败",
  "trace_id":  "abc-123",
  "timestamp": 1740391200000
```

---

## 4. 下行推送：消息到达客户端

### 4.1 Kafka 消息格式（msg-service → Kafka）

msg-service 将落库后的消息序列化为 **Protobuf Binary** 写入 Kafka，Connect Service 消费后推送到客户端。

**Kafka Topic**：`msg.push`（分区键：`receiver_uuid`，保证单用户/单群消息有序）

**Kafka Value**（`MsgPushEvent` proto，序列化为 bytes）：

```protobuf
// 待补入 proto/msg/msg_push_event.proto
message MsgPushEvent {
  string receiver_uuid = 1;  // 单聊=对端用户 UUID；群聊=群 UUID
  string device_id     = 2;  // 空字符串=广播全设备，非空=仅推指定设备
  string command       = 3;  // "MSG_PUSH" | "MSG_RECALL" | "MSG_MARK_READ"
  int32  conv_type     = 4;  // 1=单聊 2=群聊（Consumer 据此判断扩散策略）
  bytes  payload       = 5;  // 按 command 序列化的业务 proto bytes
  string trace_id      = 6;
  int64  server_ts     = 7;  // 服务端时间戳（unix毫秒）
}
```

> **为什么用 Protobuf？**  
> Kafka payload 是纯 bytes，Proto 编解码相比 JSON 体积更小（约 30-50%），且强类型，避免字段拼错。

#### 路由扩散模型（读写混合）

本项目采用**混合扩散模型**，单聊和群聊使用不同的扩散策略：

| | 单聊（conv_type=1） | 群聊（conv_type=2） |
|--|--|--|
| **扩散模型** | **写扩散**（Write Fan-out） | **读扩散**（Read Fan-out） |
| **落库** | 写 1 条消息 + 更新双方 2 条会话 | 写 1 条消息 + 更新发送者 1 条会话 |
| **Kafka receiver_uuid** | 对端用户 UUID | 群 UUID |
| **Connect 扩散** | 直接 `SendToUser(receiver_uuid)` | 查询群成员列表，逾历在线成员推送 |
| **写放大** | 无（1 条 Kafka 消息） | 无（1 条 Kafka 消息） |
| **读放大** | 无 | 有（Connect 查询群成员列表） |

**单聊写扩散流程**：
```
msg-service 落库后：
  ├─ 写 1 条 MsgPushEvent：receiver_uuid = 对端 UUID, conv_type = 1
  └─ Connect 直接 SendToUser(对端 UUID)，推送到对端所有在线设备
```

**群聊读扩散流程**：
```
msg-service 落库后：
  ├─ 写 1 条 MsgPushEvent：receiver_uuid = 群 UUID, conv_type = 2
  └─ Connect 消费后：
       ├─ 查询 Redis 群成员列表（key: group:members:{group_uuid}）
       ├─ 遍历成员，过滤发送者本人
       └─ 对每个在线成员 SendToUser(member_uuid)
```

> **为什么群聊用读扩散？**  
> 写扩散会导致 N 个群成员产生 N 条 Kafka 消息，千人群单条消息 = 1000 条 Kafka 写入，写放大严重。
> 读扩散只写 1 条 Kafka，Connect 在消费时查询群成员并逾历推送，这个“读”代价可通过 Redis 缓存降低。

### 4.2 Connect Service Kafka Consumer

```
Kafka "msg.push" 消费流程
  │
  ├─ proto.Unmarshal(msg.Value) → MsgPushEvent
  ├─ frameBytes = proto.Marshal(MessageEnvelope{command, payload, trace_id, server_ts})
  │
  ├─ 判断 conv_type:
  │    conv_type=1 (单聊)：
  │      device_id 非空 → SendToDevice(receiver_uuid, device_id, frameBytes)
  │      device_id 为空 → SendToUser(receiver_uuid, frameBytes)
  │
  └─ conv_type=2 (群聊)：
       ├─ members = Redis SMEMBERS group:members:{receiver_uuid}
       ├─ 过滤发送者本人（从 payload.from_uuid 获取）
       └─ for member in members: SendToUser(member, frameBytes)
```

### 4.3 WebSocket 下行帧（Connect → 客户端）

Connect 向 WebSocket 发送 **Binary 帧**，内容为 `MessageEnvelope` proto：

```protobuf
// proto/connect/connect.proto
message MessageEnvelope {
  string command   = 1;  // "MSG_PUSH" | "MSG_RECALL" | "MSG_MARK_READ" | "KICKOUT"
  bytes  payload   = 2;  // 按 command 序列化的业务 proto
  string trace_id  = 3;
  int64  server_ts = 4;
}
```

`command="MSG_PUSH"` 时，`payload` 反序列化为 `MsgItem`（定义见 `proto/msg/msg_common.proto`）。

### 4.4 客户端处理逻辑

```
收到 WebSocket Binary 帧
  │
  ├─ 1. proto.Unmarshal(frame) → MessageEnvelope
  ├─ 2. 按 command 路由：
  │      "MSG_PUSH"      → Unmarshal payload → MsgItem，渲染消息气泡
  │      "MSG_RECALL"    → Unmarshal payload → RecallNotice，替换气泡
  │      "MSG_MARK_READ" → Unmarshal payload → MarkReadNotice，清除红点
  │      "KICKOUT"       → 跳转登录页
  └─ 3. 按需回 ACK
```

### 4.5 接收方不在线

- Kafka Consumer 尝试推送，`SendToUser` 返回 0（无在线设备），消息丢弃（已落库）。
- 接收方上线后通过会话列表（`unread_count > 0`）感知有未读，主动调用 PullMessages 拉取。

---

## 5. 消息拉取（历史记录）

### 5.1 拉取接口

```
GET /api/v1/auth/msg/pull
Authorization: Bearer <access_token>
```

**Query 参数**：

| 参数 | 类型 | 必填 | 默认 | 说明 |
|------|------|------|------|------|
| `conv_id` | string | ✅ | - | 目标会话 ID |
| `anchor_seq` | int64 | ❌ | 0 | 锚点 seq |
| `direction` | int | ❌ | 1 | `1`=FORWARD（拉新消息），`2`=BACKWARD（加载历史） |
| `limit` | int | ❌ | 50 | 单次最多条数，上限 200 |

**方向语义**：

| direction | 含义 | anchor_seq=0 时 |
|-----------|------|-----------------|
| `1` FORWARD | 拉取 seq > anchor_seq 的消息（新消息） | 从最早开始 |
| `2` BACKWARD | 拉取 seq < anchor_seq 的消息（历史） | 从最新开始 |

> **clear_seq 过滤规则**：服务端在返回历史消息时，必须增加 SQL 过滤条件 `seq > conversation.clear_seq`，以实现彻底清空历史聊天记录的语义。  
> 这可以防止用户删除会话后卸载重装，被删除的消息“幽灵复活”。  
> 当用户从未删除过会话时，`clear_seq = 0`，不影响正常查询。

**成功响应**：

```json
{
  "code": 0,
  "data": {
    "messages": [
      {
        "msg_id":          "01HW5K9Q1ZBXK3EJGA7MKYQ4XT",
        "client_msg_id":   "c3f8a1b2-0000-0000-0000-123456789abc",
        "conv_id":         "p2p-usr_abc-usr_def",
        "seq":             42,
        "from_uuid":       "usr_abc",
        "msg_type":        1,
        "content":         "{\"text\":\"你好！\"}",
        "status":          0,
        "send_time":       1740391200000,
        "reply_to_msg_id": "",
        "at_users":        []
      }
    ],
    "has_more": false,
    "max_seq":  42
  },
  "timestamp": 1740391200000
}
```

### 5.2 批量按 ID 查询

适用于：点击引用消息跳转、推送通知点进来反查详情。

```
POST /api/v1/auth/msg/batch-get
Authorization: Bearer <access_token>
Content-Type: application/json
```

**请求体**：

```json
{
  "conv_id": "p2p-usr_abc-usr_def",
  "msg_ids": [
    "01HW5K9Q1ZBXK3EJGA7MKYQ4XT",
    "01HW5K9Q1ZBXK3EJGA7MKYQ4XU"
  ]
}
```

| 字段 | 类型 | 必填 | 校验 |
|------|------|------|------|
| `conv_id` | string | ✅ | 非空 |
| `msg_ids` | []string | ✅ | 1~50 条 |

**成功响应**：

```json
{
  "code": 0,
  "data": {
    "messages": [ /* MsgItem 数组，未找到的 ID 静默跳过 */ ]
  },
  "timestamp": 1740391200000
}
```

---

## 6. 消息撤回

### 6.1 撤回限制

- 仅**发送者本人**或**群管理员**可撤回。
- 必须在**发送后 2 分钟**内操作。
- 撤回后 `status` 置为 `1`，`content` 改写为系统提示 JSON：

```json
{ "text": "张三撤回了一条消息", "operator": "usr_abc" }
```

### 6.2 撤回接口

```
POST /api/v1/auth/msg/recall
Authorization: Bearer <access_token>
Content-Type: application/json
```

**请求体**：

```json
{
  "conv_id": "p2p-usr_abc-usr_def",
  "msg_id":  "01HW5K9Q1ZBXK3EJGA7MKYQ4XT"
}
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `conv_id` | string | ✅ | 会话 ID |
| `msg_id` | string | ✅ | 要撤回的消息 ID |

**成功响应**：

```json
{
  "code":    0,
  "message": "success",
  "timestamp": 1740391200000
}
```

### 6.3 撤回推送（下行通知）

撤回成功后，服务端会向**会话内所有在线设备**推送撤回通知：

```protobuf
MessageEnvelope {
  command = "MSG_RECALL"
  payload = RecallNotice {
    conv_id  = "p2p-usr_abc-usr_def"
    msg_id   = "01HW5K9Q1ZBXK3EJGA7MKYQ4XT"
    operator = "usr_abc"
    recall_time = 1740391260000
  }
}
```

客户端收到后，将对应消息气泡替换为"撤回了一条消息"提示。

---

## 7. 消息类型定义

`msg_type` 字段约定如下：

| 值 | 名称 | content JSON 结构 |
|----|------|-------------------|
| `1` | 文本 | `{"text": "内容"}` |
| `2` | 图片 | `{"url": "https://...", "width": 800, "height": 600, "size": 102400}` |
| `3` | 语音 | `{"url": "https://...", "duration": 5}` |
| `4` | 视频 | `{"url": "https://...", "thumb_url": "...", "duration": 30, "size": 5242880}` |
| `5` | 文件 | `{"url": "https://...", "name": "report.pdf", "size": 1048576}` |
| `6` | 位置 | `{"lat": 31.23, "lng": 121.47, "title": "上海"}` |
| `100` | 系统通知 | `{"text": "系统消息内容", "operator": "usr_xxx"}` |
| `101` | 撤回提示 | `{"text": "xxx撤回了一条消息", "operator": "usr_xxx"}` |

> **约定**：`0~99` 为普通气泡消息，`100+` 为系统/控制消息（不计入未读数）。

---

## 8. 错误码

| 错误码 | 场景 | 说明 |
|--------|------|------|
| `13001` | 发送失败 | 消息写入失败（DB/内部错误） |
| `13002` | 消息不存在 | 查询或撤回时目标消息找不到 |
| `13003` | 消息类型不支持 | `msg_type` 超出定义范围 |
| `13004` | 会话不存在 | 拉取消息时 conv_id 无效 |
| `13005` | 撤回超时 | 超过 2 分钟撤回窗口 |
| `13006` | 撤回无权限 | 非发送者且非群管理员 |
| `13007` | 内容超长 | content 超过 65536 字节 |
| `10001` | 参数错误 | 缺必填字段或格式不合法 |
| `22001` | 鉴权失败 | token 无效/过期/device_id 不匹配 |
| `32001` | 服务内部错误 | msg-service 不可用，稍后重试 |

---

## 9. 设计要点

### 9.1 幂等保证

- 每条上行消息必须携带客户端生成的 `client_msg_id`（UUID v4 推荐）。
- 服务端以 `(from_uuid, device_id, client_msg_id)` 三元组去重。
- 重复请求返回**首次成功时的响应**，不会产生重复消息。

### 9.2 seq 机制

- `seq` 是会话（`conv_id`）内**严格单调递增**的序号，由服务端 Redis `INCR` 原子分配。
- 客户端记录本地已知最大 seq，上线或有 gap 时通过 PullMessages 补齐。
- 判断是否有消息缺失：`received_seq != local_max_seq + 1`。

### 9.3 单聊会话 ID 规则

```
conv_id = "p2p-" + sorted(user_uuid_a, user_uuid_b).join("-")
// 例：user_a = "usr_abc", user_b = "usr_def"（按字典序排序）
// conv_id = "p2p-usr_abc-usr_def"
```

### 9.4 多端同步策略

- 发送方发消息后，服务端同时向发送方的**其他在线设备**推送该消息（多端同步）。
- 已读同步：调用 MarkRead 后，服务端向该用户的所有其他在线设备推送 `MSG_MARK_READ` 通知。

### 9.5 推送降级

- 若接收方设备全部离线，消息已落库，无法实时推送。
- 接收方上线后通过会话列表（`unread_count > 0`）感知有未读，主动调用 PullMessages 拉取。
- **暂不支持**离线推送通知（APNs/FCM），后续迭代添加。

---

*本文档与 `proto/msg/msg_service.proto`、`proto/msg/msg_common.proto` 保持同步。如需修改接口字段，请同步更新本文档。*
