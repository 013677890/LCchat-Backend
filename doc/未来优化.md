## 1.grpc重试过程中打Warn日志  （完成）

问题：生产环境需要可观测性。如果网络出现抖动，原生配置是‘静默重试’的，没法通过日志监控到系统的‘亚健康’状态。

改用go-grpc-middleware 的拦截器模式，利用 WithOnRetryCallback 钩子，在每次重试失败时打印 Warn 日志。这样既保证了服务的可用性，又让运维能通过监控 Warn 日志的频率，提前发现网络隐患。

### 2.限流使用redis 调整限流日志 用双重检查锁定

问题：当前的限流可能还在单机层面或者日志输出过于频繁。
建议：将限流状态存储迁移至 Redis 以支持分布式限流。在初始化限流器时，使用双重检查锁定（Double-Checked Locking）模式，确保高并发下限流器实例的唯一性与性能。同时优化限流日志，避免在达到阈值时产生海量重复日志，可以考虑采用采样打印或聚合打印的策略。

### 3. 高并发性能优化建议（Gateway 层）

#### 3.1 使用 `sync.Pool` 复用高频对象 （在qps>100000下才有收益 暂不实施）
在高并发场景下，频繁的内存分配会显著增加 GC 压力。
- **DTO 与对象复用**：对频繁创建的 LoginDTO、UserInfo 等结构体，以及 `recover` 中使用的请求快照对象，引入 `sync.Pool` 进行复用。
- **减少逃逸分析失败**：优化函数参数传递，尽量使小对象保留在栈上，减少堆内存分配。

#### 3.2 优化中间件 Context 查找 （在qps>100000下才有收益 暂不实施）
目前多个中间件（Auth, Metrics, Logger）都在重复从 `gin.Context` 提取 TraceID 并构建 `context.Context`。
- **初始化中间件**：建议在请求生命周期最开始创建一个“请求元数据”结构体并存入 `gin.Context` 指针，后续中间件直接获取指针，避免多次 `context.Value`（O(n) 复杂度）的查找开销。

#### 3.3 gRPC 连接管理与长连接复用
- **连接池化**：确保 Gateway 调用的后端 gRPC 客户端连接是单例且长连接复用的。
- **内置负载均衡**：启用 gRPC 客户端负载均衡（如 Round Robin），减少对外部负载均衡器的依赖，降低网络延迟。

#### 3.4 优化 `debug.Stack()` 与日志计算
- **按需生成堆栈**：`debug.Stack()` 性能开销极大，应严格限制在真正的服务端 Panic 时才触发，且在生产环境下可配置开关。
- **延迟日志序列化**：在日志输出前先判断级别，避免在 `Info` 级别被禁用时仍进行复杂的字段计算或字符串拼接。

#### 3.5 DTO 转换的零拷贝
- 探索使用更高效的结构体转换方式，在 DTO 与 Protobuf 结构体字段高度一致时，减少内存拷贝次数。




